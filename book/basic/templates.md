## Шаблоны

**Шаблоны** - это удобный инструмент для ускорения разработки по принципу 
DRY (Don't repeat yourself).

## Писать их нужно именно в .h файлах если есть такое разделение

Обычно над функцией или классом (ну в том месте где будут использоватся типы данных)
пишут обозначение какого-либо типа данных например
```
template<typename T>
T add(T a,T b){
    return a+b;
}
```
Теперь эта функция работает и с double и c int и с unsigned вообще все что можно прибавить.
Главное то что мы пишем обозначение какого-либо типа и даем название `T` в данном случае
и компилятор создает копии функции под каждый тип данных который мы будем использовать.
Допустим мы написали только один вызов.
```
// Ну для точности можно указать тип заранее
add<int>(1,2);
```
и компилятор создаст только одну версию с int. Если ты используеш где то double, string то он 
создаст и их.Тоже самое с классами да в классах тоже так можно
```
template<typename T>
class Storage{
public:
    T data;

    Storage(T d) : data(d) {}

    T getData() { return data};

};

```

В зависимости от использования он создасть несколько классов абсолютно разных.

Так дальше.В шаблонах можно также указывать определенные значения

```
template<typename T, int Size>
class CArray{
public:
    T data[Size];
    
    int getSize() { return Size; };

};

```
Можно теперь делать так
```
CArray<int,10> ten_array; // отдельный класс с 10 максимальными обьектами
CArray<string,100> two_array; // Тоже отдельный класс 
```

Внутри `template` можно указывать и использовать сколько угодно типов и значений
```
template<typename Tval,typename Tkey, int Size, double something ...>
Tval func(Tkey d,Tval a){
    ...
}

```


Но бывает иногда что обшая логика не подходит для определенного типа данных
тогда можно использовать `спецификацию`

```
// Общий шаблон
template<typename T>
void print(T v){
    cout << "Value: " << v << endl;
}

// Для boolean типа по другому
template <> // пустые значит специальный 
void print<bool>(bool v){
    cout << (v ? "true" : "false" ) << endl;
}

```

## Наследование от шаблонов
Допустим есть какой то базовый класс с шаблоном
```
template<typename T>
class Base{...};

```

И можно ли от него наследоватся? да можно.
Есть 3 способа:

### От определенного типа
```
class Child : public Base<int>{...};
```

### Производный тоже универсальный
```

template<typename T>
class Child : public Base<T>{...};
```


### CRTP <- Используеш свой собственный класс как параметр для родителя
```
class Child : public Base<Child>{...};
```





