## filesystem 



Для работы с путями директориями используется модуль `filesystem`

### Заголовок
```
#include <filesystem>
```

Для удобства используем псевдоним чтобы везде не писать `filesystem::`
```
namespace fs = std::filesystem;
```


### Обьекты

`fs::path` - обьект который хранит путь к файлу или к директории. Это умный обьект который 
автоматически парсит пути также является кроссплатформенным. 
У него есть несколько методов:
```
fs::path p = "data/file.txt";

// Стандартные методы
p.empty(); // true если пустой 
p.root_name(); // Показывает диск в котором находится (Windows C:)
p.root_path(); // корень пути 
p.root_directory(); // только слеш или корень 
p.relative_path(); // путь без корня 
p.parent_path(); // родительский каталог
p.stem(); // имя без расширения 
p.extension(); // Расширение файла с точкой 
p.filename(); // Возвращaет имя конечного файла

// операторы 
p1 / p2;        // объединение пути (concat с добавлением разделителя)
p1 == p2;       // сравнение путей
p1 != p2;
p1 < p2;        // лексикографическое сравнение

```

## Функции filesystem(fs)

* Информация *
```
fs::exists(p)             // true, если путь существует
fs::is_regular_file(p)    // true, если файл обычный
fs::is_directory(p)       // true, если каталог
fs::is_symlink(p)         // true, если символическая ссылка
fs::is_empty(p)           // true, если файл/каталог пустой
fs::file_size(p)          // размер файла в байтах
fs::last_write_time(p)    // время последней модификации
```
* Каталоги *
```
fs::create_directory(p)            // создать каталог
fs::create_directories(p)          // создать каталог с промежуточными
fs::remove(p)                      // удалить файл или пустой каталог
fs::remove_all(p)                  // удалить рекурсивно каталог с содержимым
fs::rename(old_path, new_path)     // переименовать/переместить
fs::current_path()                 // получить текущий рабочий каталог
fs::current_path(p)                // изменить текущий каталог
```


* Итераторы *
```
fs::directory_iterator(p)       // итератор по одному уровню каталога
fs::recursive_directory_iterator(p) // рекурсивная итерация
```

* Пути и их свойства *
```
fs::absolute(p)         // абсолютный путь
fs::canonical(p)        // канонический путь (без ".", "..", ссылки)
fs::weakly_canonical(p) // похож на canonical, но не выбрасывает исключение, если нет
fs::proximate(p, base)  // путь относительно base
fs::equivalent(p1, p2) // true если p1 и p2 указывают на один файл/каталог
```

* Копирование и перемещение *
```
fs::copy(src, dst)                          // копирование файла или каталога (по умолчанию без рекурсии)
fs::copy_file(src, dst)                     // копирование только файлов
fs::copy_symlink(src, dst)                  // копирование символической ссылки

fs::copy_options::overwrite_existing        // опция для fs::copy 

    none                    = 0,       // стандартное поведение
    skip_existing           = 1,       // пропустить файлы, если уже есть
    overwrite_existing      = 2,       // перезаписать файлы, если они существуют
    update_existing         = 4,       // перезаписать только если источник новее
    recursive               = 8,       // рекурсивно копировать каталоги
    copy_symlinks           = 16,      // копировать символические ссылки как ссылки
    skip_symlinks           = 32,      // пропустить символические ссылки
    directories_only        = 64,      // копировать только каталоги
    create_symlinks         = 128,     // создать символические ссылки вместо копирования
    create_hard_links       = 256      // создать жёсткие ссылки вместо копирования

Все эти флаги можно также комбинировать через знак |
fs::copy(src, dst, fs::copy_options::recursive | fs::copy_options::overwrite_existing);
```



* Диск *
```
fs::space(p) // возвращает struct { capacity, free, available }
```


