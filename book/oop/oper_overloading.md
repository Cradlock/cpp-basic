## Перегрузка операторов 

С++ позволяет переопределить встроенные методы: +,-,*,<,>,== и т.д, для этого нужна функция в названии которой
есть слово `operator`.

Каждый из них пишется по общему шаблону:

```
<Любой тип данных> operator <любой оператор {++,--,+,-}> ( <Принимаемые данные> ) {
    ... твой код
} 

```

В основном операции делятся на унарные и бинарные.

* `Унарный`: Работает с одним обьектом. 
```
class Point{
public: 
    Point(...) {...}

    int x,y;
    
    // Для унарных нет аргументов
    Point operator ++ () {
        this->x++;
        this->y++;
        return *this;
    }

};

```


* `Бинарный`: Работает с двумя обьектами принимает один аргумент
```
class Point{
public:
    Point(...) {...}

    int x,y;
    
    // Тут у нас есть один аргумент это обьект того же класса 
    Point operator + (const Point& other) {
        return Point{this->x+other.x,this->y+other.y};
    }
};
```
Теперь можно делать так:
```
Point a{...};
Point b{...};

// Все сработает корректно
Point c = a + b; 
```

Помимо этого бывают особые случаи:

* `<</>>`: Оператор потока вывода и ввода
В обычно случае оба операнда
```
a + b; // явлаются обьектами наших кастомных классов
```
Но в случае `<<` мы пишем так:
```

std::cout << a;

```
Обьект `std::cout` - это обьект поток `std::ostream` который является частью стандартной библиотеки и нельзя туда залесть
и добавить обработку именно нашего класса. Поэтому опертор должен быть привычной функцией а не частью класса,
и он должен возврашать тот же обьект потока, это нужно для такого синтаксиса
```
// с каждым разом после операции возврашается обьект cout и работает со следующим обьектом
std::cout << a << " - " << b;
```
Пример перегрузки:
```
class Point{
public:
    Point (...) {...}
    
    int x,y; 

    // friend чтобы он видел private поля
    friend std::ostream& operator <<(std::ostream& stream, const Point& obj){
        stream << "X: " << this->x << " Y: " << this->y;
        return stream; // обязательно вернуть поток 
    }
    
    friend std::istream operator >>(std::istream& stream, Point& obj){
        stream >> obj.x >> obj.y;
        return stream;
    }

};   
```


* `Постфиксный/префиксный `:Инкремент и дикремент
Дело в том что между:
```
++Point; // Префиксный
```
и
```
Point++; // Постфиксный 
```
есть разница
* `Префиксный`: Мы меняем обьект и сразу его используем,(эффективно)

* `Постфиксный`: Мы меняем обьект но отдаем старое значение (кушает немного больше памяти так как надо где-то хранить старое значение )

Поэтому в написании функций для этих операторов есть разница
```

class Point{
public:
    Point(...) {...}
    
    int x,y;
    
    //Префиксный    
    Point& operator ++(){
        this->x++;
        this->y++;
        return *this;
    }

    //Постфиксный 
    Point operator++(int){ // Этот int нужен только для того чтобы комплиятор отличал эти две функции,а так он не используется
        
        // создаем копию
        Point temp = *this;
        // Меняем оригинал 
        this->x++;
        this->y++;
        // Возвращаем копию 
        return temp;
    }
};

```

* `,`: Это конечно странно,но можно перегрузить запятые, зачем ну наверное для удобства.

Вот пример:
```
class MatrixFilter{
public:
    std::vector<int>& vec;

    MatrixFilter& operator , (int val) {
        vec.push_back(val);
        return *this; 
    }
};


std::vector<int> myVec;
MatrixFilter(myVec), 1, 2, 3, 4, 5;

```



* `Оператор преобразования`: Это та самая автомтическое преобразование, и самое странное что я видел в с++

```
class Drob{ // класс дробей

    int num,den; // делитель,знаменатель
public:
    Drob(int n,int d ) : num(n), den(d) {}

    // И вот он оператор преобразования 
    operator double() const {
        return static_cast<double>(num) / den;
    }

};

```


Нужен чтобы без всяких методов он автоматически мог превртатится в double 

```
Drob a{1,2};
double b = a; // И вот it`s magic он сам превратится в double 
```



