## Преобразование типов
*Преобразование типов* - это возможность представить обьект как нечто другое,есть всего 
несколько способов это сделать.


### Автоматический  `static_cast`
Если у нас есть производный и родитель.
или заранее похожие типы то они могут сами преобазоватся.

```
Child obj[};

Parent pr_obj{obj};
```

или 

```
double a = 12.1;

int b = a;
```

Также можно использовать функцию `static_cast`.

```
Child obj{};

//          Указываем тип заранее 
Parent pr_obj{static_cast<Parent>(obj)};
```

`static_cast` - Переделывает тип во время компиляции.

### Динамическое преобразование  `dynamic_cast` 
`static_cast` - используется во время компиляции а вот `dynamic_cast` во время runtime он в во время работы 
может преобразовать. Он также проверяет возможно ли это преобразование, правда скорость от этого снижается.
Но эту функцию можно использовтаь только на ссылки и указатели которые содержат хотя бы одну виртуальную функцию.

Если не сработало то `dynamic_cast` вернет nullptr.

```
Child obj{...};
Parent* parent_obj = dynamic_cast<Parent*>(&obj);
// func - виртуальная функция
parent_obj->func();
```

`dynamic_cast` - Одинаково работает с ссылками и указателями,но так как ссылка не может быть пустой 
`dynamic_cast` не сможет вернуть nullptr. Поэтому срабатывает исключение.



### C - стиль 
Просто представить один класс как другой
```
(int)variable;
```


### Через `reinterpret_cast`
Самый опасный способ, буквально переделывает байты,никакой безопасности
```
float b = 12312.12312312f;

int a = *reinterpret_cast<int*>(&b);
```








