## Виртуальные функции и их переопределение 


При вызове функции в С++ программа должна понять какую именно ее реализацию вызывать
есть два вида связи.

### Статическое
Это когда на этапе компиляции заранее известно какая именно функция.
Расмотрим следующий случай. 

```

class Parent{
public:
    // Какая нибудь функция 
    void func() { ... }
};

class Child : public Parent {
public: 
    // Та же функция 
    void func() {...}
}
```

Теперь у нас есть функция которая определена в обоих классах с таким же названием

```
Parent* pr_obj = nullptr;

Child obj{...};
pr_obj = &obj;
pr_obj->func(); 
```
При таком случае будет вызвана функция именно Родителя так как при статическом обьявлении
реализация зависит от типа самого указателя. Так можно делать потому что Child является 
производным от Parent так что можно создать указатель.

### Динамическое
При динамическом обьявленнии мы можем указать прямо в родителе что какой то метод может 
использоватся в его производных делается это так.
```
class Parent{
public:
    // Ключевой модификатор virtual 
    virtual void func() {...}
};

```

Теперь в производном классе 
```
class Child : public Parent{
public:
    // Ключевой модификатора override 
    void func () override {...}
}
```
Теперь прежде чем сразу выполнить код он будет сначала смотреть производный класс если 
там такой метод если нет выполняет тот что в Родителе.

```
Parent* pr_obj = nullptr;
Child obj{...};
pr_obj = &obj; 
pr_obj->func(); // вызовется тот что переопределен
```


## Но 
стоит учитывать что создание виртуальных функций кушает больше памяти 



## Запрет переопределения
Можно в производных классах запретить переопредление с помошью `final`


```
class Parent{

virtual void func() final {
    ...
}

}; 
```

После такого в дочерних классах нельзя больше переопределять.







