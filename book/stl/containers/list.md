## list

`list` - Двусвязный список, где каждый элемент имеет доступ к своим соседям. 


### Заголовок
```
#include <list>
```


### Инициализация

1. Пустой список
```
std::list<int> lst;
```

2. Копия другого 
```
std::list<int> lst = other_list;

std::list<int> lst(other_list);
```

3. Заранее указаны данные
```
std::list<int> lst(5); // состоит из 5 чисел 0 

std::list<int> lst(5,2); // состоит из 5 чисел 2

std::list<int> lst{12,3,43}; // сразу указаны данные 

std::list<int> lst = {121,1221,21}; // тоже сразу указаны данные
```


### Получение элементов
> **ВАЖНО:** У `list` НЕТ доступа по индексу `lst[i]` или метода `at()`. Чтобы найти элемент в середине, нужно перебирать его с начала.

* `lst.front()` — получить ссылку на первый элемент.
* `lst.back()` — получить ссылку на последний элемент.
* `lst.begin()` / `lst.end()` — итераторы для обхода (используются в циклах).

---

### Добавление
Операции вставки в `list` очень эффективны ($O(1)$), так как не требуют копирования всего массива или сдвига элементов.

* `lst.push_back(val)` — добавить в конец.
* `lst.push_front(val)` — добавить в начало.
* `lst.emplace_back(args...)` — сконструировать объект сразу в конце.
* `lst.emplace_front(args...)` — сконструировать объект сразу в начале.
* `lst.insert(it, val)` — вставить `val` в позицию перед итератором `it`.
* `lst.emplace(it, args...)` — сконструировать объект перед итератором `it`.

---

### Удаление

* `lst.pop_back()` — удалить последний элемент.
* `lst.pop_front()` — удалить первый элемент.
* `lst.erase(it)` — удалить элемент, на который указывает итератор.
* `lst.remove(val)` — удалить **ВСЕ** элементы, значение которых равно `val`.
* `lst.clear()` — полностью очистить список.

---

### Специфические методы (фишки list)
Так как `list` — это не массив, стандартные алгоритмы (например, `std::sort`) с ним не работают. Используй встроенные методы:

* `lst.sort()` — сортирует элементы списка (эффективнее, чем копировать в вектор).
* `lst.unique()` — удаляет идущие подряд дубликаты (лучше вызывать после сортировки).
* `lst.reverse()` — разворачивает порядок элементов.
* `lst.splice(it, other_list)` — перемещает элементы из `other_list` в текущий список в позицию `it` **БЕЗ копирования** объектов (просто перекидывает указатели между узлами).





